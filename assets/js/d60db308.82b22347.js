"use strict";(self.webpackChunk_cli_forge_docs_site=self.webpackChunk_cli_forge_docs_site||[]).push([[4336],{32191:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var a=n(62540),t=n(43023);const s={id:"composable-options",title:"Composable Options",description:"This example demonstrates how to extract common options into a reusable function, to share\nacross multiple commands.\n\nThe main idea is to create a function that takes an initial CLI and performs some operations on it to be used in a command's builder function. If you extract multiple of these, you can use `chain` to compose them together. There is also a helper called `makeComposableBuilder` that can be used to create these composable builders, without having to worry about getting the type annotations correct.\n\nIf you are only useing @cli-forge/parser, `chain` is still available to use and a different helper, `makeComposableOption` is available to create composable options. These would be used like below:\n```typescript\nconst withName = makeComposableOption('name', {\n  type: 'string',\n});\nconst initialParser = new ArgvParser();\nconst parser = chain(initialParser, withName, /* ... */);\n```\n\nNote: This example goes really far with the composable options, and is likely overkill for most CLI commands. In general, I'd only recommend extracting options into a composable builder if they are shared across multiple commands. If the options are only used in a single command, it's probably best to keep them in the command builder directly.\n",hide_title:!0},i="Composable Options",r={id:"examples/composable-options",title:"Composable Options",description:"This example demonstrates how to extract common options into a reusable function, to share\nacross multiple commands.\n\nThe main idea is to create a function that takes an initial CLI and performs some operations on it to be used in a command's builder function. If you extract multiple of these, you can use `chain` to compose them together. There is also a helper called `makeComposableBuilder` that can be used to create these composable builders, without having to worry about getting the type annotations correct.\n\nIf you are only useing @cli-forge/parser, `chain` is still available to use and a different helper, `makeComposableOption` is available to create composable options. These would be used like below:\n```typescript\nconst withName = makeComposableOption('name', {\n  type: 'string',\n});\nconst initialParser = new ArgvParser();\nconst parser = chain(initialParser, withName, /* ... */);\n```\n\nNote: This example goes really far with the composable options, and is likely overkill for most CLI commands. In general, I'd only recommend extracting options into a composable builder if they are shared across multiple commands. If the options are only used in a single command, it's probably best to keep them in the command builder directly.\n",source:"@site/docs/examples/composable-options.md",sourceDirName:"examples",slug:"/examples/composable-options",permalink:"/cli-forge/examples/composable-options",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"composable-options",title:"Composable Options",description:"This example demonstrates how to extract common options into a reusable function, to share\nacross multiple commands.\n\nThe main idea is to create a function that takes an initial CLI and performs some operations on it to be used in a command's builder function. If you extract multiple of these, you can use `chain` to compose them together. There is also a helper called `makeComposableBuilder` that can be used to create these composable builders, without having to worry about getting the type annotations correct.\n\nIf you are only useing @cli-forge/parser, `chain` is still available to use and a different helper, `makeComposableOption` is available to create composable options. These would be used like below:\n```typescript\nconst withName = makeComposableOption('name', {\n  type: 'string',\n});\nconst initialParser = new ArgvParser();\nconst parser = chain(initialParser, withName, /* ... */);\n```\n\nNote: This example goes really far with the composable options, and is likely overkill for most CLI commands. In general, I'd only recommend extracting options into a composable builder if they are shared across multiple commands. If the options are only used in a single command, it's probably best to keep them in the command builder directly.\n",hide_title:!0},sidebar:"tutorialSidebar",previous:{title:"Option Choices",permalink:"/cli-forge/examples/limit-choices"},next:{title:"Configuration Files",permalink:"/cli-forge/examples/configuration-files"}},l={},c=[{value:"Code",id:"code",level:2},{value:"Usage",id:"usage",level:2}];function m(e){const o={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(o.header,{children:(0,a.jsx)(o.h1,{id:"composable-options",children:"Composable Options"})}),"\n",(0,a.jsx)(o.p,{children:"This example demonstrates how to extract common options into a reusable function, to share\nacross multiple commands."}),"\n",(0,a.jsxs)(o.p,{children:["The main idea is to create a function that takes an initial CLI and performs some operations on it to be used in a command's builder function. If you extract multiple of these, you can use ",(0,a.jsx)(o.code,{children:"chain"})," to compose them together. There is also a helper called ",(0,a.jsx)(o.code,{children:"makeComposableBuilder"})," that can be used to create these composable builders, without having to worry about getting the type annotations correct."]}),"\n",(0,a.jsxs)(o.p,{children:["If you are only useing ",(0,a.jsx)(o.a,{href:"https://github.com/cli-forge/parser",children:(0,a.jsx)(o.strong,{children:"@cli-forge/parser"})}),", ",(0,a.jsx)(o.code,{children:"chain"})," is still available to use and a different helper, ",(0,a.jsx)(o.code,{children:"makeComposableOption"})," is available to create composable options. These would be used like below:"]}),"\n",(0,a.jsx)(o.pre,{children:(0,a.jsx)(o.code,{className:"language-typescript",children:"const withName = makeComposableOption('name', {\n  type: 'string',\n});\nconst initialParser = new ArgvParser();\nconst parser = chain(initialParser, withName, /* ... */);\n"})}),"\n",(0,a.jsx)(o.p,{children:"Note: This example goes really far with the composable options, and is likely overkill for most CLI commands. In general, I'd only recommend extracting options into a composable builder if they are shared across multiple commands. If the options are only used in a single command, it's probably best to keep them in the command builder directly."}),"\n",(0,a.jsx)(o.h2,{id:"code",children:"Code"}),"\n",(0,a.jsx)(o.pre,{children:(0,a.jsx)(o.code,{className:"language-ts",metastring:'title="Composable Options" showLineNumbers',children:"import { CLI, chain, cli, makeComposableBuilder } from 'cli-forge';\n\n// The generic type parameter `T` allows typescript to carry the types\n// of the options through the chain of composable options.\n// If we have a command that uses multiple composable options, the type\n// of argv in the handler will correctly reflect the options that were\n// supplied both directly and through the composable options.\nfunction withName<T extends CLI>(argv: T) {\n  return argv.option('name', {\n    type: 'string',\n    description: 'Your name',\n    required: true,\n  });\n}\n\n// For convenience, cli-forge provides a helper function to create composable\n// builders. This function takes a function that takes an initial CLI instance\n// and returns a new CLI instance with additional options, commands etc.\n// This can then be used with the `chain` function to compose multiple builders.\nconst withGreeting = makeComposableBuilder((args) =>\n  args.option('greeting', {\n    type: 'string',\n    description: 'The greeting to use',\n    default: 'Hello',\n  })\n);\n\nconst withFarewell = makeComposableBuilder((args) =>\n  args.option('farewell', {\n    type: 'string',\n    description: 'The farewell to use',\n    default: 'Goodbye',\n  })\n);\n\nconst subcommand = cli('converse', {\n  description: 'A quick chat',\n  builder: (args) => chain(args, withName),\n  handler: (args) => {\n    console.log(`[${args.name}]: hello!`);\n  },\n});\n\nconst withSubcommand = makeComposableBuilder((args) =>\n  args.commands(subcommand)\n);\n\nconst withGreetCommand = makeComposableBuilder((args) =>\n  args.command('greet', {\n    builder: (args) => chain(args, withName, withGreeting),\n    handler: (args) => {\n      console.log(`${args.greeting}, ${args.name}!`);\n    },\n  })\n);\n\nconst withFarewellCommand = makeComposableBuilder((args) =>\n  args.command('farewell', {\n    builder: (args) => chain(args, withName, withFarewell),\n    handler: (args) => {\n      console.log(`${args.farewell}, ${args.name}!`);\n    },\n  })\n);\n\ncli('composable-options', {\n  builder: (args) =>\n    chain(args, withGreetCommand, withFarewellCommand, withSubcommand),\n}).forge();\n\n"})}),"\n",(0,a.jsx)(o.p,{children:(0,a.jsx)(o.a,{href:"/playground/#PTAEBUAsFNQMwPYBskIO4EsB2BzUTtYATBaAZywHIAXUE0AQywE9rJs8AnaBlZgGlCcGbaJ1AZa1aCjIAoEKFERmAB2gBlAMacMq2qqQNmOTggCuWIksgibGMqDI69tMpAtJrAI1jQAbrzmItDWDI4MoFgIRNAAVo7OuvoAdHIYALaqCJy0AN4AvvBmGaCU0bEAXHBklHLpWTn5oADCADIAkoJattjdBIIZDADW0C0IjWQM3kjQAELmGF5ioEVwJWVaBAC0iJw40JQA3PWKULAHWGIYWkpqsKoMwhnQ0uIABuDvjCjojtT3JKuJQIUBaJ6cZg2WAA9TyRQIODQ0AIfQYBBYf6QMzmHCQZE9BjYFFIrQTbJTGawVHUdGYtKKDpItCwWz+WCRMkZIZWGx2cxkcigDLmJC0wywLkU6azFFojFkQTKWHQBRgRGMfb+CRYZG2KyzcSYFBgnLcLTUJBQ7hwWYW5E0ulYuws7hqpzmVSGDChUDeBBsOgYc2WqFMaxsHF4gnkhCU2WOhVpOCWC100CYNgAOQYLwAPOBQNAAB7SKyOdodAB8AAonjh-JUIABKUB5OSgISvcycXX1-wpRNYGvlXOHQTtzudlVNyhkai6XCUfgdqexIHyrCzgCaFnEWDHy9Xne4AEdFtwiE2F+ZoCvOwVmycCqcwAAxHKmrDsrA+rBaO8wR2PYDlAVQzH8DB10YUAYCQdRxBTf9aQxEEwW4EJTUmGVVUUbxFmWTgyBSCB2EcJC01Q6gRiFSIKJQ3U2DsajRgiXVsEkDBeFaTodXnJgAPdcMu2oHtMRgq40B4jo+Oo-9YEzfEGCIIhOIxbih0VLCeSIRxXi0BkwCgBwwSYaFdV8UABV9RTkXeQlsG+ej02oUEpTjWARTFPRZXwpZYiItIyUxWhFIAcW4V4OFAABeYUaPGbCqQWfyxBrOt9jIVsYqrVd62IocR1MaAoqXCdjzudRZ3nRccCPKc6HIFxN1nc5QGK0q8FcqzBXqtdoDgBhRWoWcAAkZFQPrHzkJ96mC+cM0kSA3yeaAWRNOKhlGRLpWSgiAvS-Lstyzt8sHTcR0G7h1qQZc2wqmcyhqjg+s7ddmoY1qYHgVabrQ6zXsawbhtnMKEBibxmHHVdptmuR5rccxvC5HTYqAjAR2C9kiPHe63qa5JPrKABBUBzxuYYwVsag+r8wimwynAstiqsqaJYd8sERScxeZt71g8NDQZo6Wbxqd5uQaAUlQHAa3eABtAASPIzoPF4CgAXSbODUAAQneWaHxXR8TnhhVQqWjQkZR4TNoS2N43mfa0sZ5mcryzKUht8sazIa2Jh05sZtNhHFrYCKSuoRLUbt7aHZwlLCMOzLjo9pmvYD8MisimnyoaumAuFlPRYcjnMq5paecA8Kc44PmKv1IghdAV3jrFhqJdmaWEFl95lbOjraVwApBH7z21egAp9cNqcR5hoO4dDxSVuuibo9t+K46S2ZE4O1uWbT4jvaIS7fomu7JynAuxCLpm29L12K+zMcn+Ws+UHrhrG+b-ecvb8WFSS27r3Me6crprQmiPUAoDiITyngbE4DU54PgXiHAgmN45Um2JpC+q5r6cFvm7E64tehlyZq-COrx15WFfivCBKBqFEFflbZGmcrD10fCkEC0AayzSAA",children:"View on TypeScript Playground"})}),"\n",(0,a.jsx)(o.h2,{id:"usage",children:"Usage"}),"\n",(0,a.jsx)(o.pre,{children:(0,a.jsx)(o.code,{className:"language-shell",children:'node ./composable-options.js greet --name sir --greeting "Good day"\n'})}),"\n",(0,a.jsx)(o.pre,{children:(0,a.jsx)(o.code,{className:"language-shell",children:'node ./composable-options.js farewell --name madame --farewell "Goodbye"\n'})}),"\n",(0,a.jsx)(o.pre,{children:(0,a.jsx)(o.code,{className:"language-shell",children:"node ./composable-options.js converse --name sir\n"})}),"\n",(0,a.jsxs)(o.blockquote,{children:["\n",(0,a.jsx)(o.p,{children:"These examples are ran as e2e tests on pull-requests and releases to verify they are accurate and up to date. If you see any issues, please open an issue on the github repo."}),"\n"]})]})}function p(e={}){const{wrapper:o}={...(0,t.R)(),...e.components};return o?(0,a.jsx)(o,{...e,children:(0,a.jsx)(m,{...e})}):m(e)}},43023:(e,o,n)=>{n.d(o,{R:()=>i,x:()=>r});var a=n(63696);const t={},s=a.createContext(t);function i(e){const o=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function r(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),a.createElement(s.Provider,{value:o},e.children)}}}]);