"use strict";(self.webpackChunk_cli_forge_docs_site=self.webpackChunk_cli_forge_docs_site||[]).push([[5909],{36700:e=>{e.exports=JSON.parse('[{"files":[{"path":"/home/runner/work/cli-forge/cli-forge/examples/arguments-of.ts","contents":"import { cli, ArgumentsOf, makeComposableBuilder, chain, CLI } from \'cli-forge\';\\n\\nconst withName = makeComposableBuilder((args) =>\\n  args.option(\'name\', {\\n    type: \'string\',\\n    description: \'Your name\',\\n    required: true,\\n  })\\n);\\n\\nconst withAge = makeComposableBuilder((args) =>\\n  args.option(\'age\', {\\n    type: \'number\',\\n    description: \'Your age\',\\n    required: true,\\n  })\\n);\\n\\nconst builder = <T extends CLI>(args: T) => chain(args, withName, withAge);\\n\\nconst myCLI = cli(\'arguments-of\', {\\n  builder: (args) => builder(args),\\n  handler: (args) => CLIHandler(args),\\n});\\n\\ntype Arguments = ArgumentsOf<typeof builder>;\\n\\nfunction CLIHandler(args: Arguments) {\\n  console.log(`Hello, ${args.name}!`);\\n  console.log(`You are ${args.age.toFixed(0)} years old.`);\\n}\\n\\nif (require.main === module) {\\n  (async () => {\\n    await myCLI.forge();\\n  })();\\n}\\n"}],"data":{"id":"arguments-of","title":"Arguments Of","commands":["{filename} --name John --age 42"],"description":"When building a CLI, and especially if taking advantage of [composition](./composable-options), it can be necessary to have a typescript type that respresents the resolved arguments of a CLI command. For example, if you abstract the handler of a command into a separate function, the argument of that function would be typed as the arguments of the CLI command.\\n\\nCLI Forge provides the `ArgumentsOf` type to help with this. It takes a CLI instance or a function that returns a CLI instance and returns the type of the arguments that the CLI command handler will receive. There are some difficulties with typescript support for circular references, so its usage isn\'t perfect, but if used with composable builders directly you avoid these problems.\\n","entryPoint":"/home/runner/work/cli-forge/cli-forge/examples/arguments-of.ts","fileMap":{}}},{"files":[{"path":"/home/runner/work/cli-forge/cli-forge/examples/basic-cli.ts","contents":"import cliForge from \'cli-forge\';\\n\\nconst cli = cliForge(\'basic-cli\')\\n  // Requires a command to be provided\\n  .demandCommand()\\n\\n  // Registers \\"hello\\" command\\n  .command(\'hello\', {\\n    // Builder is used to define the command\'s options\\n    builder: (args) =>\\n      args.option(\'name\', {\\n        type: \'string\',\\n        description: \'The name to say hello to\',\\n        default: \'World\',\\n      }),\\n    // Handler is used to define the command\'s behavior\\n    handler: (args) => {\\n      // Note: name is always defined because it has a default value.\\n      console.log(`Hello, ${args.name}!`);\\n    },\\n  })\\n  .command(\'goodbye\', {\\n    builder: (args) =>\\n      args\\n        .option(\'name\', {\\n          type: \'string\',\\n          description: \'The name to say goodbye to\',\\n          default: \'World\',\\n        })\\n        .option(\'excited\', {\\n          type: \'boolean\',\\n          description: \'Whether to say goodbye excitedly\',\\n        }),\\n    handler: (args) => {\\n      // Note the typing of `args` here. It\'s inferred from the builder.\\n      // The `name` option is always defined because it has a default value.\\n      // The `excited` option is optional because it doesn\'t have a default value.\\n      console.log(`Goodbye, ${args.name}${args.excited ? \'!\' : \'.\'}`);\\n    },\\n  });\\n\\n// We export the CLI for a few reasons:\\n// - Testing\\n// - Composition (a CLI can be a subcommand of another CLI)\\n// - Docs generation\\nexport default cli;\\n\\n// Calling `.forge()` executes the CLI. It\'s single parameter is the CLI args\\n// and they default to `process.argv.slice(2)`.\\nif (require.main === module) {\\n  (async () => {\\n    await cli.forge();\\n  })();\\n}\\n"}],"data":{"id":"basic-cli","title":"Basic CLI","commands":["{filename} hello --name sir","{filename} goodbye --name madame"],"description":"This is a simple example that demonstrates how to create a basic CLI using cli-forge\\n","entryPoint":"/home/runner/work/cli-forge/cli-forge/examples/basic-cli.ts","fileMap":{}}},{"files":[{"path":"/home/runner/work/cli-forge/cli-forge/examples/choices.ts","contents":"import cliForge from \'cli-forge\';\\n\\nconst cli = cliForge(\'basic-cli\')\\n  .demandCommand()\\n  .command(\'hello\', {\\n    builder: (args) =>\\n      args\\n        .option(\'name\', {\\n          type: \'string\',\\n          description: \'The name to say hello to\',\\n          required: true,\\n\\n          // Choices limits valid values for the option.\\n          // If the provided value is not in the choices array, an error will be thrown.\\n          choices: [\'sir\', \'madame\'],\\n        })\\n        .option(\'phrase\', {\\n          type: \'string\',\\n          default: \'hello\',\\n\\n          // Choices can also be provided as a function that returns an array of valid values.\\n          // This can be useful if the choices are dynamic or need to be calculated at runtime.\\n          choices: () => [\'hello\', \'hi\', \'hey\'],\\n        }),\\n    // Handler is used to define the command\'s behavior\\n    handler: (args) => {\\n      // Note: args.name is typed as \'sir\' | \'madame\' due to the choices array\\n      console.log(`${args.phrase}, ${args.name}!`);\\n    },\\n  });\\n\\nexport default cli;\\n\\nif (require.main === module) {\\n  (async () => {\\n    await cli.forge();\\n  })();\\n}\\n"}],"data":{"id":"limit-choices","title":"Option Choices","commands":["{filename} hello --name sir"],"description":"This is a simple example that demonstrates how to limit choices for a given option.\\n\\nChoices are checked after `coerce` if it is also provided, so be sure that the `coerce` function returns a value that is in the choices array.\\n\\nChoices can be provided as an array of valid values or as a function that returns an array of valid values. Note that when returning the array from a function, providing \\"as const\\" is necessary to narrow the typing of the argument. This may not be possible if the choices are dynamic or need to be calculated at runtime, in which case the typing will remain as a broader type (e.g. `string` instead of `\'a\' | \'b\'`).\\n","entryPoint":"/home/runner/work/cli-forge/cli-forge/examples/choices.ts","fileMap":{}}},{"files":[{"path":"/home/runner/work/cli-forge/cli-forge/examples/composable-options.ts","contents":"import { CLI, chain, cli, makeComposableBuilder } from \'cli-forge\';\\n\\n// The generic type parameter `T` allows typescript to carry the types\\n// of the options through the chain of composable options.\\n// If we have a command that uses multiple composable options, the type\\n// of argv in the handler will correctly reflect the options that were\\n// supplied both directly and through the composable options.\\nfunction withName<T extends CLI>(argv: T) {\\n  return argv.option(\'name\', {\\n    type: \'string\',\\n    description: \'Your name\',\\n    required: true,\\n  });\\n}\\n\\n// For convenience, cli-forge provides a helper function to create composable\\n// builders. This function takes a function that takes an initial CLI instance\\n// and returns a new CLI instance with additional options, commands etc.\\n// This can then be used with the `chain` function to compose multiple builders.\\nconst withGreeting = makeComposableBuilder((args) =>\\n  args.option(\'greeting\', {\\n    type: \'string\',\\n    description: \'The greeting to use\',\\n    default: \'Hello\',\\n  })\\n);\\n\\nconst withFarewell = makeComposableBuilder((args) =>\\n  args.option(\'farewell\', {\\n    type: \'string\',\\n    description: \'The farewell to use\',\\n    default: \'Goodbye\',\\n  })\\n);\\n\\nconst subcommand = cli(\'converse\', {\\n  description: \'A quick chat\',\\n  builder: (args) => chain(args, withName),\\n  handler: (args) => {\\n    console.log(`[${args.name}]: hello!`);\\n  },\\n});\\n\\nconst withSubcommand = makeComposableBuilder((args) =>\\n  args.commands(subcommand)\\n);\\n\\nconst withGreetCommand = makeComposableBuilder((args) =>\\n  args.command(\'greet\', {\\n    builder: (args) => chain(args, withName, withGreeting),\\n    handler: (args) => {\\n      console.log(`${args.greeting}, ${args.name}!`);\\n    },\\n  })\\n);\\n\\nconst withFarewellCommand = makeComposableBuilder((args) =>\\n  args.command(\'farewell\', {\\n    builder: (args) => chain(args, withName, withFarewell),\\n    handler: (args) => {\\n      console.log(`${args.farewell}, ${args.name}!`);\\n    },\\n  })\\n);\\n\\ncli(\'composable-options\', {\\n  builder: (args) =>\\n    chain(args, withGreetCommand, withFarewellCommand, withSubcommand),\\n}).forge();\\n"}],"data":{"id":"composable-options","title":"Composable Options","commands":["{filename} greet --name sir --greeting \\"Good day\\"","{filename} farewell --name madame --farewell \\"Goodbye\\"","{filename} converse --name sir"],"description":"This example demonstrates how to extract common options into a reusable function, to share\\nacross multiple commands.\\n\\nThe main idea is to create a function that takes an initial CLI and performs some operations on it to be used in a command\'s builder function. If you extract multiple of these, you can use `chain` to compose them together. There is also a helper called `makeComposableBuilder` that can be used to create these composable builders, without having to worry about getting the type annotations correct.\\n\\nIf you are only useing @cli-forge/parser, `chain` is still available to use and a different helper, `makeComposableOption` is available to create composable options. These would be used like below:\\n```typescript\\nconst withName = makeComposableOption(\'name\', {\\n  type: \'string\',\\n});\\nconst initialParser = new ArgvParser();\\nconst parser = chain(initialParser, withName, /* ... */);\\n```\\n\\nNote: This example goes really far with the composable options, and is likely overkill for most CLI commands. In general, I\'d only recommend extracting options into a composable builder if they are shared across multiple commands. If the options are only used in a single command, it\'s probably best to keep them in the command builder directly.\\n","entryPoint":"/home/runner/work/cli-forge/cli-forge/examples/composable-options.ts","fileMap":{}}},{"files":[{"path":"/home/runner/work/cli-forge/cli-forge/examples/configuration-files/configured-cli.ts","contents":"import { ConfigurationProviders, cli } from \'cli-forge\';\\n\\n(async () =>\\n  await cli(\'configured-cli\', {\\n    builder: (args) =>\\n      args\\n        .option(\'name\', { type: \'string\' })\\n        .option(\'greeting\', { type: \'string\' })\\n        .option(\'farewell\', { type: \'string\' })\\n\\n        // Allows loading configuration values from the \'configured-cli\' entry in package.json.\\n        .config(ConfigurationProviders.PackageJson(\'configured-cli\'))\\n\\n        // Allows loading configuration values from the root of \'configured-cli.config.json\'.\\n        .config(ConfigurationProviders.JsonFile(\'configured-cli.config.json\'))\\n\\n        // Allows loading configuration values from the \'configured-cli\' entry in \'other.config.json\'.\\n        .config(\\n          ConfigurationProviders.JsonFile(\'other.config.json\', \'configured-cli\')\\n        ),\\n\\n    handler: (args) => {\\n      console.log(`${args.greeting}, ${args.name}!`);\\n      console.log(`${args.farewell}, ${args.name}!`);\\n    },\\n  }).forge())();\\n"},{"path":"/home/runner/work/cli-forge/cli-forge/examples/configuration-files/configured-cli.config.json","contents":"{\\n  \\"greeting\\": \\"Hello!\\"\\n}\\n"},{"path":"/home/runner/work/cli-forge/cli-forge/examples/configuration-files/other.config.json","contents":"{\\n  \\"configured-cli\\": { \\"farewell\\": \\"Goodbye\\" }\\n}\\n"},{"path":"/home/runner/work/cli-forge/cli-forge/examples/configuration-files/package.json","contents":"{\\n  \\"name\\": \\"some-package\\",\\n  \\"configured-cli\\": {\\n    \\"name\\": \\"bar\\"\\n  }\\n}\\n"}],"data":{"id":"configuration-files","title":"Configuration Files","commands":[{"command":"{filename}","title":"Pure Config","description":"Note that no arguments are provided to the CLI. In this case, all arguments are being loaded from the configuration files.","assertions":[{"contains":"Hello!"},{"contains":"Goodbye"},{"contains":"bar"}]},{"command":"{filename} --greeting \\"Welcome\\"","title":"CLI Arguments","description":"In this case, the CLI arguments are being used to override the configuration file.","assertions":[{"contains":"Welcome"},{"contains":"Goodbye"},{"contains":"bar"}]}],"description":"This example demonstrates how to enable loading arguments from a configuration file. The `.config()` method configures the CLI to load arguments from a configuration file. The method takes a single argument, a `ConfigurationProvider`. [See the docs for `ConfigurationProvider` here](/api/parser/namespaces/ConfigurationFiles/type-aliases/ConfigurationProvider).\\n\\nFor convenience, `cli-forge` exports some built-in configuration providers. Currently, there are two built-in configuration providers: `JsonFile` and `PackageJson`.\\n\\nUsage of each of these is demonstrated below. Note that when using multiple configuration files, the order in which they are loaded is important. The last configuration file loaded will override any previously loaded configuration files.\\n\\nWhen both environment variables and configuration files are used, the order of precedence is as follows:\\n- CLI Arguments\\n- Environment Variables\\n- Configuration Files\\n- Default Values\\n\\nThis is based on the idea of highest specificity. CLI Arguments are always provided directly by the user. Environment variables can change system-to-system. Configuration files are specific to the project. Default values are equal for all instances of the CLI.\\n","entryPoint":"/home/runner/work/cli-forge/cli-forge/examples/configuration-files/configured-cli.ts","fileMap":{"/home/runner/work/cli-forge/cli-forge/examples/configuration-files/configured-cli.ts":"configured-cli.ts","/home/runner/work/cli-forge/cli-forge/examples/configuration-files/package.json":"package.json","/home/runner/work/cli-forge/cli-forge/examples/configuration-files/configured-cli.config.json":"configured-cli.config.json","/home/runner/work/cli-forge/cli-forge/examples/configuration-files/other.config.json":"other.config.json"}}},{"files":[{"path":"/home/runner/work/cli-forge/cli-forge/examples/conflicts-and-implications.ts","contents":"import cli from \'cli-forge\';\\n\\ncli(\'conflicts-and-implications\', {\\n  builder: (args) =>\\n    args\\n      .option(\'source\', {\\n        describe: \'Source database\',\\n        type: \'string\',\\n      })\\n      .option(\'target\', {\\n        describe: \'Target database\',\\n        type: \'string\',\\n      })\\n      .option(\'dry-run\', {\\n        describe: \'Simulate the migration without making changes\',\\n        type: \'boolean\',\\n      })\\n      .option(\'force\', {\\n        describe: \'Force the migration even if there are warnings\',\\n        type: \'boolean\',\\n      })\\n      .option(\'backup\', {\\n        describe: \'Where should the backup be stored\',\\n        type: \'string\',\\n      })\\n      // Conflicts creates mutually exclusive arguments. Validation will throw an error if both options are provided.\\n      // In this case, it makes sense that the user wouldn\'t want to both simulate and force a migration.\\n      .conflicts(\'dry-run\', \'force\')\\n\\n      // Implies creates mutually required arguments. Validation will throw an error if the first argument is provided without the second.\\n      // Practically in this case, this means that if the user provides the --force option, they must also provide the --backup option.\\n      .implies(\'force\', \'backup\'),\\n  handler: (args) => {\\n    // ...\\n  },\\n}).forge();\\n"}],"data":{"id":"conflicts-and-implications","title":"Conflicts and Implications","commands":["{filename} --source=old --target=new","{filename} --source=old --target=new --dry-run"],"description":"This example illustrates how `.conflicts()` and `.implies()` can be used to enforce mutually exclusive options and mutually required options, respectively.\\n","entryPoint":"/home/runner/work/cli-forge/cli-forge/examples/conflicts-and-implications.ts","fileMap":{}}},{"files":[{"path":"/home/runner/work/cli-forge/cli-forge/examples/default-values.ts","contents":"import cliForge from \'cli-forge\';\\n\\nconst cli = cliForge(\'default-values\').command(\'$0\', {\\n  builder: (args) =>\\n    args\\n      .option(\'name\', {\\n        type: \'string\',\\n        description: \'The name to say hello to\',\\n        // Setting the default value directly\\n        default: \'World\',\\n      })\\n      .option(\'greeting\', {\\n        type: \'string\',\\n        description: \'The greeting to use\',\\n        // Setting the default value to an object containing a value and a description\\n        default: {\\n          // The value here may be different across command runs. In docs,\\n          // we want a consistent description of the default value.\\n          value: process.env[\'DEFAULT_VALUES_HELLO\'] ?? \'Hello\',\\n          description: \'The default greeting\',\\n        },\\n      })\\n      .option(\'farewell\', {\\n        type: \'string\',\\n        description: \'The farewell to use\',\\n        // Setting the default value to an object containing a function that returns a value and a description\\n        default: {\\n          // The value here may be different across command runs. In docs,\\n          // we want a consistent description of the default. Using a factory function\\n          // gives more flexibility compared to the value + description method above.\\n          factory: () => {\\n            if (process.arch === \'x64\') {\\n              return \'Goodbye\';\\n            } else {\\n              return \'Goodnight\';\\n            }\\n          },\\n          description: \'The default farewell\',\\n        },\\n      }),\\n  handler: (args) => {\\n    console.log(`${args.greeting}, ${args.name}!`);\\n    console.log(`${args.farewell}, ${args.name}!`);\\n  },\\n});\\n\\nexport default cli;\\n\\nif (require.main === module) {\\n  (async () => {\\n    await cli.forge();\\n  })();\\n}\\n"}],"data":{"id":"default-values","title":"Default Values","commands":["{filename}","{filename} --name sir","{filename} --greeting \\"Good day\\"",{"command":"{filename} --farewell \\"Goodbye\\"","env":{"DEFAULT_VALUES_HELLO":"Greetings"}}],"description":"This is a simple example that demonstrates the various ways you can set default values for options.\\n\\nThe default value can be set via the `default` property in an option definition. This can be done in three ways:\\n- Setting the `default` property to a value directly\\n- Setting the `default` property to an object containing function that returns a value and a description\\n- Setting the `default` property to an object containing a value and a description\\n\\nSetting the `default` property to a value directly is the simplest way to set a default value, but can lead to some odd behavior if the value isn\'t consistent. For example, if the default value is the value of an environment variable that may differ among users then the actual default value will be different for each user. In this case in documentation, it would be better to tell users a description of the default value rather than the actual value.\\n","entryPoint":"/home/runner/work/cli-forge/cli-forge/examples/default-values.ts","fileMap":{}}},{"files":[{"path":"/home/runner/work/cli-forge/cli-forge/examples/env.ts","contents":"import cli from \'cli-forge\';\\n\\nconst myCLI = cli(\'env-options\')\\n  .command(\'hello\', {\\n    builder: (args) =>\\n      args\\n        .option(\'name\', {\\n          type: \'string\',\\n          description: \'The name to say hello to\',\\n          required: true,\\n        })\\n        .option(\'greeting\', {\\n          type: \'string\',\\n          // Providing a string to `env` here allows the `name` option\\n          // to be read from an environment variable. The environment variable\\n          // key is transformed to upper snake case. e.g.\\n          // - `name` -> `NAME`\\n          // - `myOption` -> `MY_OPTION`\\n          // - `NAME` -> `NAME`\\n          //\\n          // If a prefix is provided via a parent `.env()` call, the prefix\\n          // will be applied here as well. Setting `env` to false will disable\\n          // environment variable reading for this option, even if `.env()` was\\n          // called on the parent CLI.\\n          env: \'GREETING\',\\n        }),\\n    handler: (args) => {\\n      console.log(`Hello, ${args.name}!`);\\n    },\\n  })\\n  // Invoking .env() enables reading arguments from environment variables.\\n  // The env key is based on the option name. e.g. For the option \'name\', and\\n  // the CLI name \'env-options\', the environment variable would be ENV_OPTIONS_NAME.\\n  .env();\\n\\n(async () => {\\n  await myCLI.forge();\\n})();\\n"}],"data":{"id":"env-options","title":"Environment Options","commands":[{"command":"{filename} hello","env":{"ENV_OPTIONS_NAME":"sir","ENV_OPTIONS_GREETING":"hello"}}],"description":"This example demonstrates how you can register options that are set via environment variables. There are two levels\\nof environment variable support:\\n- Global: By calling `.env()` on the CLI instance or parser, you can enable environment variable support for all options.\\n- Local: By providing an `env` key on an option, you can enable or disable environment variable support for that option only.\\n\\nIn either case, there are a few common properties to be aware of:\\n- Prefix: Set via `prefix` on the object passed to .env(), or disabled by passing `false` with the `env` property on an option. Setting a prefix will automatically add the prefix to the environment variable key. When calling `.env()` on a CLI, the prefix defaults to the top-level command name.\\n- Reflect: By default if environment variable handling is enabled, environment variables are reflected to `process.env`. This can be disabled by passing `{reflect: false}` to `.env()` or setting `env` to contain `{reflect: false}` on an option.\\n- Populate: By default if environment variable handling is enabled, environment variables are used to populate options. This can be disabled by passing `{populate: false}` to `.env()` or setting `env` to contain `{populate: false}` on an option. This allows you to reflect environment variables to `process.env` without populating options from the env.\\n- Key: The key used when populating an option from env or reflecting to `process.env`. By default, the key is the option name in upper snake case. This can be overridden by setting the `env` key on an option.\\n\\nOptions passed on the command line will always take precedence over environment variables. Environment variables override configuration files as well as default values.\\n","entryPoint":"/home/runner/work/cli-forge/cli-forge/examples/env.ts","fileMap":{}}},{"files":[{"path":"/home/runner/work/cli-forge/cli-forge/examples/interactive-subshell.ts","contents":"import cliForge from \'cli-forge\';\\n\\nconst state = {\\n  defaultHost: \'example.com\',\\n  auth: {} as Record<string, { user: string; pass?: string }>,\\n};\\n\\nconst cli = cliForge(\'interactive-subshell\')\\n  // Enables launching an interactive subshell.\\n  // For this example, the subshell would be launched if the user\\n  // runs either:\\n  // - `node ./interactive-subshell.ts`\\n  // - `node ./interactive-subshell.ts foo`\\n  .enableInteractiveShell()\\n  .command(\'auth\', {\\n    builder: (args) =>\\n      args\\n        .option(\'host\', { type: \'string\', default: state.defaultHost })\\n        .command(\'login\', {\\n          builder: (args) => {\\n            return args\\n              .positional(\'user\', { type: \'string\', required: true })\\n              .option(\'pass\', { type: \'string\' });\\n          },\\n          handler: (args) => {\\n            state.auth ??= {};\\n            state.auth[args.host] = {\\n              user: args.user,\\n              pass: args.pass,\\n            };\\n            console.log(\'Logged in to\', args.host, \'as\', args.user);\\n          },\\n        })\\n        .command(\'logout\', {\\n          handler: (args) => {\\n            delete state.auth[args.host];\\n            console.log(\'Logged out of\', args.host);\\n          },\\n        }),\\n  })\\n  .command(\'lorem\', {\\n    handler: (args) => {\\n      console.log(\'lorem ipsum\');\\n    },\\n  });\\n\\n// We export the CLI for a few reasons:\\n// - Testing\\n// - Composition (a CLI can be a subcommand of another CLI)\\n// - Docs generation\\nexport default cli;\\n"}],"data":{"id":"interactive-subshell","title":"Interactive Subshell","commands":[],"description":"This example demonstrates how to create an interactive subshell using cli-forge. The subshell is a simple REPL that can execute commands or shell commands. To launch the subshell, run the script with no arguments, or a command that contains subcommands and no handler.\\nThe subshell presents a prompt that includes the current command chain, and executes the command when the user presses enter. If the command is not recognized, it is executed as a shell command. Notably, the subshell is very basic. It does not currently support command history, tab completion, or other advanced features.\\n","entryPoint":"/home/runner/work/cli-forge/cli-forge/examples/interactive-subshell.ts","fileMap":{}}},{"files":[{"path":"/home/runner/work/cli-forge/cli-forge/examples/middleware.ts","contents":"import cliForge from \'cli-forge\';\\n\\nconst cli = cliForge(\'basic-cli\')\\n  // Requires a command to be provided\\n  .demandCommand()\\n\\n  // Middleware registered on parent commands will be invoked before the child command\'s middleware\\n  .middleware(() => {\\n    console.log(\'ABOUT TO RUN A COMMAND\');\\n  })\\n\\n  // Registers \\"hello\\" command\\n  .command(\'hello\', {\\n    // Builder is used to define the command\'s options\\n    builder: (args) =>\\n      args\\n        .option(\'name\', {\\n          type: \'string\',\\n          description: \'The name to say hello to\',\\n          default: \'World\',\\n        })\\n        // Middleware can mutate the args object\\n        .middleware((args) => {\\n          args.name = args.name.toUpperCase();\\n        })\\n        // Multiple middleware can be registered\\n        .middleware(() => {\\n          console.log(\'HELLO MIDDLEWARE\');\\n        }),\\n    // Handler is used to define the command\'s behavior\\n    handler: (args) => {\\n      console.log(`Hello, ${args.name}!`);\\n    },\\n  });\\n\\n// We export the CLI for a few reasons:\\n// - Testing\\n// - Composition (a CLI can be a subcommand of another CLI)\\n// - Docs generation\\nexport default cli;\\n\\n// Calling `.forge()` executes the CLI. It\'s single parameter is the CLI args\\n// and they default to `process.argv.slice(2)`.\\nif (require.main === module) {\\n  (async () => {\\n    await cli.forge();\\n  })();\\n}\\n"}],"data":{"id":"middleware","title":"Middleware","commands":["{filename} hello --name sir"],"description":"This is a simple example that demonstrates how to register middleware that run before the command handler.\\nMiddleware can do **a lot** of things.  Almost everything that middleware can do could be done at the beginning\\nof the handler function, but middleware keeps the handler clean and focused on the command\'s behavior as well\\nas being much more composable.\\n\\nSome things middleware can do:\\n- Modify the arguments object\\n- Perform validation that takes multiple arguments into account\\n- Perform side effects\\n","entryPoint":"/home/runner/work/cli-forge/cli-forge/examples/middleware.ts","fileMap":{}}},{"files":[{"path":"/home/runner/work/cli-forge/cli-forge/examples/object-dot-notation.ts","contents":"import cliForge from \'cli-forge\';\\n\\nconst cli = cliForge(\'object-notation\', {\\n  builder: (args) =>\\n    args.option(\'foo\', {\\n      type: \'object\',\\n      properties: {\\n        bar: {\\n          type: \'object\',\\n          properties: {\\n            baz: {\\n              type: \'number\',\\n            },\\n          },\\n        },\\n        qux: {\\n          type: \'number\',\\n        },\\n        arr: {\\n          type: \'array\',\\n          items: \'number\',\\n        },\\n      },\\n      additionalProperties: \'string\',\\n    }),\\n  handler: (args) => {\\n    // Types should be inferred correctly\\n    args.foo?.bar?.baz?.toFixed();\\n    args.foo?.[\'blam\'].charAt(0);\\n    // It\'s an array of numbers\\n    args.foo?.arr?.reduce((acc, val) => acc + val, 0);\\n  },\\n});\\n\\n// We export the CLI for a few reasons:\\n// - Testing\\n// - Composition (a CLI can be a subcommand of another CLI)\\n// - Docs generation\\nexport default cli;\\n\\n// Calling `.forge()` executes the CLI. It\'s single parameter is the CLI args\\n// and they default to `process.argv.slice(2)`.\\nif (require.main === module) {\\n  (async () => {\\n    await cli.forge();\\n  })();\\n}\\n"}],"data":{"id":"object-dot-notation","title":"Object Arguments","commands":["{filename} --foo.bar.baz 42 --foo.qux 42 --foo.arr 1 2 3 --foo.blam hello"],"description":"This is a simple example that demonstrates passing object-valued options to a command. Note that\\nthe object-valued options are passed as dot-notation strings. These can be nested for complex option\\nstructures that contain object properties that are themselves objects.\\n\\n> Note: This example is a bit more abstract that the others, as real world use cases for object-valued\\n> options and especially nested objects are less common. This example is included to demonstrate the\\n> flexibility of the CLI Forge APIs and the ability to handle complex option structures with type safety.\\n","entryPoint":"/home/runner/work/cli-forge/cli-forge/examples/object-dot-notation.ts","fileMap":{}}},{"files":[{"path":"/home/runner/work/cli-forge/cli-forge/examples/option-groups.ts","contents":"\\nimport { cli } from \'cli-forge\';\\n\\nconst myCLI = cli(\'demo\', {\\n  builder: (args) =>\\n    args\\n      .option(\'firstName\', {\\n        type: \'string\',\\n        description: \'The name to say hello to\',\\n      })\\n      .option(\'lastName\', {\\n        type: \'string\',\\n        description: \'The last name to say hello to\',\\n      })\\n      .option(\'age\', {\\n        type: \'number\',\\n        description: \'The age of the person\',\\n      })\\n      .option(\'street\', {\\n        type: \'string\',\\n        description: \'The street where the person lives\',\\n        group: \'address\',\\n      })\\n      .option(\'city\', {\\n        type: \'string\',\\n        description: \'The city where the person lives\',\\n        group: \'address\',\\n      })\\n      .group(\'basic-info\', [\'firstName\', \'lastName\', \'age\']),\\n  handler: (args) => {\\n    // not important\\n  },\\n});\\n\\nif (require.main === module) myCLI.forge();\\n"}],"data":{"id":"option-groups","title":"Option Groups","commands":["{filename} --help"],"description":"Options can be grouped together in the help output by using the `group` method. This will also affect generated documentation. The `sortOrder` parameter can be used to control the order in which groups are displayed. Lower values will be displayed first. If two groups have the same `sortOrder`, they will be sorted alphabetically.\\n\\nOptions can be placed in a group in one of 2 ways:\\n- An explicit call to `.group` as part of the command\'s builder function.\\n- By passing a `group` property in the option definition.\\n","entryPoint":"/home/runner/work/cli-forge/cli-forge/examples/option-groups.ts","fileMap":{}}},{"files":[{"path":"/home/runner/work/cli-forge/cli-forge/examples/parser-only.ts","contents":"import { parser } from \'@cli-forge/parser\';\\n\\nconst argv = parser()\\n  .option(\'name\', {\\n    type: \'string\',\\n    description: \'The name to say hello to\',\\n    default: \'World\',\\n  })\\n  .parse(process.argv.slice(2));\\n\\nconsole.log(`Hello, ${argv.name}!`);\\n"}],"data":{"id":"parser-only","title":"Parser Only","commands":["{filename} --name sir"],"description":"This example demonstrates how to use [@cli-forge/parser](https://npmjs.com/@cli-forge/parser) to interpret CLI arguments\\nwithout the need for a CLI framework. For single-command CLIs, this may be enough.\\n","entryPoint":"/home/runner/work/cli-forge/cli-forge/examples/parser-only.ts","fileMap":{}}},{"files":[{"path":"/home/runner/work/cli-forge/cli-forge/examples/test-harness.ts","contents":"import { describe, it } from \'node:test\';\\nimport * as assert from \'node:assert\';\\n\\n// We can reuse the CLI from the basic-cli example\\nimport cli from \'./basic-cli\';\\nimport { TestHarness } from \'cli-forge\';\\n\\ndescribe(\'Basic CLI\', () => {\\n  it(\'should parse the hello command\', async () => {\\n    // The TestHarness is used to simulate CLI invocations, without actually running the commands.\\n    // If you want to test how the CLI is parsing arguments, you can use the TestHarness.\\n    // If you actually want to test the CLI handlers, you should extract the handler logic\\n    // to a separate function and test that function directly.\\n    const harness = new TestHarness(cli);\\n\\n    // The parse method returns the parsed arguments and the command chain that was resolved.\\n    // The command chain contains each command that was resolved during parsing. If its empty,\\n    // then the root command was resolved. If it contains [\'hello\'], then the hello command was resolved.\\n    const { args, commandChain } = await harness.parse([\\n      \'hello\',\\n      \'--name\',\\n      \'sir\',\\n    ]);\\n\\n    assert.deepStrictEqual(commandChain, [\'hello\']);\\n    assert.deepStrictEqual(args, { name: \'sir\', unmatched: [] });\\n  });\\n});\\n"}],"data":{"id":"test-harness","title":"Using the Test Harness","commands":["--test {filename}"],"description":"This is a simple example that demonstrates how to create a basic CLI using cli-forge\\n","entryPoint":"/home/runner/work/cli-forge/cli-forge/examples/test-harness.ts","fileMap":{}}}]')}}]);